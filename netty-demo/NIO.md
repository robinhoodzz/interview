### 要想弄清NIO, 先要理解BIO

阻塞出现在那里?

客户端 -> 服务器 -> IO

1. accept方法是阻塞的

2. IO操作时, 要么读, 要么写. 单线程环境下而言   读操作没有完的时候, 写操作是不能去做的
    2.1. 原因: 读写操作用的是同一根管道流
    2.2. 如果多线程操作管道流,可以被看做是非阻塞, 现在针对单线程环境下, 要么是读完, 要是写完

3. BIO中, 不可能只有一个客户端进行连接

客户端1 \_             IO线程1
          服务器 -> /-
客户端2/-           \_ IO线程2

    * 是不是这样就是同步非阻塞的呢?
    * 不全是, 针对每一个IO操作是阻塞的, 要么读, 要么写. 对于所有IO请求, 是非阻塞的
    * 阻塞更多的描述是 IO本身的操作

BIO有问题
    客户端与服务端交互的本质是数据交流:  客户端IO  <->  socket(连接操作,为了获取IO)  <->  服务端IO
    用线程的模式弊端: 开销浪费, 每个客户端连接, 都要创建线程, 来抢夺CPU的资源. 新能消耗在线程切换上. 多线程利用CPU的本质没有得到体现
    所以, 有Socket连接的时候, 不要new Thread, 有IO操作的时候再开启线程

BIO中, 线程池已经有解决方案, 是不是就不用NIO了? 因为性能开销通过线程池的方式解决
    线程池 进行IO操作的时候, 分配一个线程给你去进行执行run任务
    newFixedThreadPool(60) VS newCachedThreadPool()
    问题1: 线程池只分配了 固定数量(60)个, 超过这个固定数量, 就得等待,等待过程就容易造成超时
    前者是有数量限制的, 后者没有上线的数量(启动时上来创建一批)
    使用线程池只是伪异步IO, 仅仅是对IO操作进行控制
    问题2: 使用线程池也不能适应 高并发的场景?

4. NIO出场
    * 同步非阻塞
    * 非阻塞
        * 客户端连接服务端 --- 服务端 连接请求(记录下来, 问问要不要IO操作)

    * BIO存在的问题
        1. 每一个socket连接服务端都会立刻开启一个线程处理 --> 连接不开启线程, IO时才开启线程
        2. 每个IO完成之后, 线程就会销毁 --> 好不容易开启的通道, 不能轻易销毁(资源浪费)

        3. 解决:
            1. 在服务端有一个主线程 main, 负责记录客户端的连接操作
            2. 先对比一下:
                BIO:     ServerSocket    Socket

                NIO:
                ServerSocketChannel     服务端
                SocketChannel           客户端

                客户端的一个状态(读,写?) -> 状态(码) -> new IO Thread
                问题: 同步非阻塞体现在哪儿?
                    阻塞: IO读或者写没有彻底完成之前, 不能进行其他的操作, 即不能同时读写

                所以要同时读写, 需要有一个Buffer
                Buffer底层是数组
                    position 初始位置
                    capacity 容量
                    limit    初始化


        4. 总结























---

为什么 accept方法是阻塞的?

* 掉用 accept 方法后，服务端进入阻塞状态，应该是在操作系统层次上进行了阻塞，因为没有客户端的到来，所以没有必要浪费CPU的时间。

* 调用了native方法进行了阻塞，具体和平台有关。如果在mac下（unix),会进入java.net.PlainSocketImpl类的native void socketAccept(SocketImpl s)。查看openjdk1.7的源码，/solaris/native/java/net/PlainSocketImpl.c中的Java_java_net_PlainSocketImpl_socketAccept方法中，有for (;;) 循环完成了阻塞。


