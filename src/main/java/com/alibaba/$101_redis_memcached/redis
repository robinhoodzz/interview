1、redis 的 list 结构相关的操作

(1)用作堆栈
lpush key value 先进后出
(2)用作队列
rpush key value 先进先出

查询
lrange key start stop  (0表示第一个,-1表示最后一个)

(3)
lpop key
出栈\出队列,第一个元素
rpop key
出栈\出队列,最后一个元素
(4)llen key
返回长度

(5)lindex key index
返回索引位置的元素

(6)lset key index value
设置索引位置的值

(7)ltrim key start stop
值保留索引内的值,其余删除

2、redis数据结构
(1)string                 key value形式    用法:set key value  ;  get key value
(2)hash 哈希              键值对集合       用法:hmset myhash key1 value1 key2 value2    ;  hget myhash key1
(3)list 列表              字符串列表       用法:lpush mylist value1    ;   lrange mylist 0 -1
(4)set  无序集合          字符串集合       用法:sadd myset value    ;    smembers myset
(5)zset 有序集合          有序字符串集合   用法:zadd myszset score member   ;   zrange myszset 0 -1 withscore  ; score用于排序,通常用数字表示
set 用来求交集、并集

3、Reids 的主从复制机制原理
分为全量和增量同步,可以采用一主多从或者级联结构

1）从服务器连接主服务器，发送SYNC命令;
2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令;
3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令;
4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照;
5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令;
6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令;

注意问题:
在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。

由于从服务器会丢弃所有旧数据,载入主服务器的数据,如果主服务器发生崩溃并重启,由于关闭持久化,重启后会有一个空的数据集
这时候从服务器也会变成空的

4、redis的过期策略和内存淘汰策略
过期策略
	1、定时过期 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
	2、惰性过期 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
	3、定期过期 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
redis中同时使用了惰性过期和定期过期两种策略

内存淘汰策略
	指内存不足时,处理新写入且需要申请额外空间的数据
	noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
	allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
	allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
	volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
	volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
	volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
